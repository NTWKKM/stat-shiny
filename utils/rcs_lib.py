import numpy as np
import pandas as pd
import patsy
import plotly.graph_objects as go
from lifelines import CoxPHFitter

from logger import get_logger
from utils.data_cleaning import prepare_data_for_analysis

logger = get_logger(__name__)


def fit_cox_rcs(
    df: pd.DataFrame,
    duration_col: str,
    event_col: str,
    rcs_var: str,
    adjust_cols: list[str],
    knots: int = 4,
    ref_value: float | None = None,
    var_meta: dict[str, dict] | None = None,
) -> tuple[go.Figure, pd.DataFrame, dict[str, dict] | None]:
    """
    Perform Restricted Cubic Spline (RCS) analysis for Cox Proportional Hazards.
    Uses patsy's 'cr' (natural cubic spline) basis.
    """
    # 1. Prepare Data
    req_cols = [duration_col, event_col, rcs_var] + adjust_cols
    # Ensure numeric
    numeric_cols = [duration_col, event_col, rcs_var]
    # Guard against overlaps/duplicates in adjust_cols
    adjust_cols = [
        c
        for c in dict.fromkeys(adjust_cols)
        if c not in {rcs_var, duration_col, event_col}
    ]

    try:
        data, missing_info = prepare_data_for_analysis(
            df,
            required_cols=req_cols,
            numeric_cols=numeric_cols,
            var_meta=var_meta,
            handle_missing="complete-case",
        )
    except Exception as e:
        return go.Figure(), pd.DataFrame(), {"error": str(e)}

    if len(data) == 0:
        return go.Figure(), pd.DataFrame(), {"error": "No data after cleaning"}

    # 2. Build Formula
    # cr() in patsy stands for Natural Cubic Spline (similar to rcs in R)
    # We use -1 to remove intercept because CoxPHFitter adds its own baseline hazard handling
    # but strictly speaking Cox model formula implies no intercept.
    # We'll construct the matrix manually to ensure we keep the design_info for prediction.

    formula_rhs = f"cr({rcs_var}, df={knots}) - 1"
    if adjust_cols:
        formula_rhs += " + " + " + ".join(adjust_cols)

    try:
        # Build design matrix
        y, X = patsy.dmatrices(
            f"{duration_col} + {event_col} ~ {formula_rhs}",
            data,
            return_type="dataframe",
        )

        # NOTE: patsy returns an intercept column by default unless -1 is used,
        # but even with -1, sometimes we need to be careful.
        # lifelines CoxPHFitter expects a DataFrame of covariates.

        # FIX: Drop the first spline column to avoid multicollinearity (columns sum to 1)
        # Find columns generated by cr()
        spline_cols = [c for c in X.columns if "cr(" in c]
        if spline_cols:
            col_to_drop = spline_cols[0]
            logger.info(
                f"Dropping spline column '{col_to_drop}' to avoid multicollinearity."
            )
            # IMPORTANT: Capture design_info BEFORE dropping columns
            design_info = X.design_info
            X = X.drop(columns=[col_to_drop])
        else:
            col_to_drop = None
            design_info = X.design_info

        # Fit Model
        cph = CoxPHFitter()
        # Combine X and duration/event for fitting
        fit_data = pd.concat([X, data[[duration_col, event_col]]], axis=1)
        # Handle duplicate columns if any
        fit_data = fit_data.loc[:, ~fit_data.columns.duplicated()]

        cph.fit(fit_data, duration_col=duration_col, event_col=event_col)

        # 3. Prediction (HR Profile)
        # Reference value (default to median)
        if ref_value is None:
            ref_value = data[rcs_var].median()

        # Create range for rcs_var
        x_min, x_max = data[rcs_var].min(), data[rcs_var].max()
        # Add buffer
        padding = (x_max - x_min) * 0.05
        pred_x = np.linspace(x_min - padding, x_max + padding, 200)

        # Create prediction dataframe
        pred_df = pd.DataFrame({rcs_var: pred_x})

        # Set adjustment vars to their means/modes
        for col in adjust_cols:
            if pd.api.types.is_numeric_dtype(data[col]):
                pred_df[col] = data[col].mean()
            else:
                # For categorical, use mode (most frequent)
                mode_val = data[col].mode()[0]
                pred_df[col] = mode_val

        # Transform pred_df using the SAME design info as the training data
        # This ensures the spline basis is identical
        pred_X = patsy.build_design_matrices(
            [design_info], pred_df, return_type="dataframe"
        )[0]

        # Calculate log hazard relative to reference
        # We need the reference row transformed as well
        ref_df = pred_df.iloc[[0]].copy()
        ref_df[rcs_var] = ref_value
        ref_X = patsy.build_design_matrices(
            [design_info], ref_df, return_type="dataframe"
        )[0]

        # FIX: Drop the same column from prediction matrices if we dropped it from training
        if col_to_drop and col_to_drop in pred_X.columns:
            pred_X = pred_X.drop(columns=[col_to_drop])
        if col_to_drop and col_to_drop in ref_X.columns:
            ref_X = ref_X.drop(columns=[col_to_drop])

        # Contrast: X_pred - X_ref
        contrast = pred_X.values - ref_X.values

        # Log HR = contrast * beta
        # Check dimensions
        if contrast.shape[1] != len(cph.params_):
            logger.error(
                f"Shape mismatch: Contrast {contrast.shape[1]} vs Params {len(cph.params_)}"
            )
            return (
                go.Figure(),
                pd.DataFrame(),
                {
                    "error": f"Shape mismatch: contrast columns ({contrast.shape[1]}) != model params ({len(cph.params_)})"
                },
            )

        beta = cph.params_.values
        log_hr = contrast.dot(beta)

        # Variance of Log HR = contrast * Cov * contrast.T
        # We only need diagonals (variance of each point)
        cov_mat = cph.variance_matrix_.values
        var_log_hr = np.sum(contrast.dot(cov_mat) * contrast, axis=1)
        se_log_hr = np.sqrt(var_log_hr)

        # Convert to HR and CI
        hr = np.exp(log_hr)
        ci_lower = np.exp(log_hr - 1.96 * se_log_hr)
        ci_upper = np.exp(log_hr + 1.96 * se_log_hr)

        # 4. Plotting
        fig = go.Figure()

        # Confidence Interval (Band)
        fig.add_trace(
            go.Scatter(
                x=np.concatenate([pred_x, pred_x[::-1]]),
                y=np.concatenate([ci_upper, ci_lower[::-1]]),
                fill="toself",
                fillcolor="rgba(0,100,80,0.2)",
                line=dict(color="rgba(255,255,255,0)"),
                hoverinfo="skip",
                name="95% CI",
            )
        )

        # Main HR Line
        fig.add_trace(
            go.Scatter(
                x=pred_x,
                y=hr,
                mode="lines",
                line=dict(color="rgb(0,100,80)", width=2),
                name="Hazard Ratio",
            )
        )

        # Reference Line
        fig.add_shape(
            type="line",
            x0=x_min,
            y0=1,
            x1=x_max,
            y1=1,
            line=dict(color="gray", dash="dash", width=1),
        )

        # Reference Point Marker
        fig.add_trace(
            go.Scatter(
                x=[ref_value],
                y=[1],
                mode="markers",
                marker=dict(color="red", size=8, symbol="diamond"),
                name=f"Reference ({ref_value:.2f})",
            )
        )

        # Density / Rug plot at the bottom (Optional but nice)
        # Use simple rug plot logic
        rug_data = data[rcs_var].sample(
            min(500, len(data)), random_state=42
        )  # Sample if too large
        fig.add_trace(
            go.Scatter(
                x=rug_data,
                y=[0.1] * len(rug_data),  # Place near bottom
                mode="markers",
                marker=dict(color="black", size=5, symbol="line-ns-open"),
                name="Observations",
                showlegend=False,
                yaxis="y2",
            )
        )

        # Layout
        fig.update_layout(
            title=f"Restricted Cubic Spline: {rcs_var} (Ref={ref_value:.2f})",
            xaxis_title=rcs_var,
            yaxis_title="Hazard Ratio (95% CI)",
            template="plotly_white",
            height=550,
            hovermode="x unified",
            yaxis2=dict(
                domain=[0, 0.1],  # Bottom 10% for rug
                showgrid=False,
                zeroline=False,
                showticklabels=False,
                overlaying="y",
                range=[0, 1],
            ),
            yaxis=dict(
                domain=[0.15, 1],  # Top 85% for main plot
            ),
        )

        # Stats table (AIC, p-value for non-linearity is complex to extract easily without nested models,
        # so we return model summary)
        stats_df = cph.summary[["coef", "exp(coef)", "p", "z"]].reset_index()
        stats_df.rename(columns={"p": "P-value", "exp(coef)": "HR"}, inplace=True)
        stats_df["Method"] = f"RCS (knots={knots})"

        return fig, stats_df, missing_info

    except Exception as e:
        logger.error(f"RCS Fit Error: {e}")
        return go.Figure(), pd.DataFrame(), {"error": str(e)}
